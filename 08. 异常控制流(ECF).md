<center>08. 异常控制流(Exceptional Control Flow, ECF)</center>
-----
[TOC]

## 1. 异常控制流

​	从处理器上电到断电为止，程序计数器假设一个值的序列`a0,a1,...,ak,...`，其中，每个`ak`是某个指令`Ik`的地址。每次从`ak`到`ak+1`的过渡称为<font color=red>控制转移</font>。这样的控制转移序列叫做处理器的<font color=red>控制转移</font>。到目前为止，我们已经学过了两种改变控制流的方式：

- 跳转、分支

- 调用、返回

这两种操作对应于程序内部状态变化的反映，没有办法应对更加复杂的系统状态变化，例如：系统状态不是被内部程序变量捕获的、也不一定要和程序的执行相关，如下：

- 一个硬件定时器产生信号

- 包到达网络适配器

- 子进程结束，创造这些子进程的父进程得到通知

​	现代操作系统通过使控制流发生突变来对上述情况作出反应，这些突变，称为<font color=red>异常控制流(Exceptional Control Flow, ECF)</font>。异常控制流发生在计算机系统的各个层次。

- **异常(exception)**：异常位、于硬件和操作系统交界的部分，响应硬件检测到的事件。

- **系统调用**：系统调用是为应用程序提供到操作系统的入口点的异常，<font color=red>属于异常，不属于进程切换</font>。

- **进程切换**：在硬件计时器和操作系统下，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。

- **信号**：信号位于应用层和操作系统的交界之处。

- **非本地跳转**：ECF 的一种应用层实现形式。

  接下来我们就来分析这四种跨越计算机不同层级的异常控制流机制。

## 2. 异常(Exception)

​	异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。<font color=red>异常</font>就是控制流中的突变，用来响应处理器状态中的某些变化。处理器状态变化称为<font color=red>事件</font>。当事件发生时，处理器会通过一张叫做<font color=red>异常表(exception table)</font>的跳转表，进行一个<font color=red>间接过程调用(异常)</font>，到一个专门设计用来处理这类事件的操作系统子程序，即<font color=red>异常处理程序(exception handler)</font>。具体过程如下图所示：

![](./images/8-3.jpg)

### 2.1 异常处理

​	系统中为异常分配了一个唯一的非负整数的<font color=red>异常号(exception ber)</font>。异常号主要有两种：

- 处理器设计者分配：例如被零除、缺页、内存访问违例、断点以及算术运算溢出。

- 操作系统内核设计者分配：例如系统调用和来自外部I/O设备的信号。

  <font color=red>异常(间接过程调用)</font>类似于过程调用，但是有一些重要的不同之处：

- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中；异常则是根据其类型，返回地址要么是当前指令，要么是下一条指令或不返回。

- 处理器也把一些额外的处理器状态压入栈里，在处理程序返回时，重新开始执行中断的程序会需要这些状态。

- 如果控制从应用程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中.

- 异常处理程序运行在<font color=red>内核模式</font>下，对所有的系统资源都有完全的访问权限。

### 2.2 异常的分类

​	异常可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)、终止(error)。

| 类别 |       原因        | 异步/同步 |       返回行为       |        示例         |
| :--: | :---------------: | :-------: | :------------------: | :-----------------: |
| 中断 | 来自I/O设备的信号 |   异步    | 总是返回到下一条指令 | 计时器中断、I/O中断 |
| 陷阱 |    有意的异常     |   同步    | 总是返回到下一条指令 |   系统调用、断点    |
| 故障 | 潜在可恢复的错误  |   同步    |  可能返回到当前指令  |      缺页异常       |
| 终止 |  不可恢复的错误   |   同步    |       不会返回       |      非法指令       |

​	<font color=red>异步异常</font>称之为中断、硬件中断不是由任何一条专门的指令造成的，从这个意义上说它是异步的；<font color=red>同步异常</font>是执行当前指令的结果，我们把这类指令叫做<font color=red>故障指令(faulting instruction)</font>。

#### 1. 中断

​	中断的异常处理程序称为<font color=red>中断处理程序(interrupt handler)</font>。

![](./images/8-3-1.png)

<center><font color=red>中断处理(interrupt handling)</font></center>

#### 2. 陷阱和系统调用

​	陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的借口，叫做<font color=red>系统调用</font>。用户程序经常需要向内核请求服务，比如读一个文件(read)、加载一个新的程序(execve)、创建一个新的进程(fork)、或者终止当前进程(exit)，系统提供了一条特殊的`syscall n`指令，执行`syscall`指令会导致一个到异常处理程序的陷阱，这个处理器程序解析参数，并调用适当的内核程序。

![](./images/8-3-2.png)

<center><font color=red>陷阱处理(trap handling)</font></center>

#### 3. 故障

​	故障由错误情况引起，它能被故障处理程序修正。当故障发生时，转移至故障处理程序。如果能修正这个错误情况，返回故障的指令并重新执行它；否则，返回到内核中的`abort`例程，终止引起故障的应用程序。

![](./images/8-3-3.png)

<center><font color=red>故障处理(fault handling)</font></center>

​	一个典型的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。然后将相应的页加载成功后，返回故障的指令，正确执行。

#### 4. 终止

​	终止是不可恢复的致命错误造成的成果，处理程序将控制权返回给一个`abort`例程，该例程会终止这个应用程序。

### 2.3 Linux/x86-64 系统中的异常

​	x86-64 系统定义了高达256种不同的异常类型，0～31 号码对应的是由Intel架构师定义的异常，32～255 号码对应的是操作系统定义的中断和陷阱。

#### 1. Linux/x86-64故障和终止

- 除法错误
- 一般保护检查
- 缺页
- 机器检查

#### 2. Linux/x86-64 系统调用

​	系统调用和与它们相关联的包装函数都称为<font color=red>系统级函数</font>。所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的。

## 3. 进程(process)

​	<font color=red>进程(process)</font>的经典定义就是<font color=red>一个执行中程序的实例</font>。系统中的每个程序都运行在某个进程的<font color=red>上下文</font>中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及文件描述符的集和(正好符合进程是处理器、主存及 I/O 设备的抽象)。进程提供给应用程序两个非常关键的抽象：

- 一个独立的逻辑控制流：它提供一个假象，好像我们的程序独占地使用处理器。
- 一个私有的地址空间：它提供一个假象，好像我们的程序独占地使用内存系统。

### 3.1 逻辑控制流

​	<font color=red>程序计数器(PC)</font>的值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令，PC值的序列叫做<font color=red>逻辑控制流</font>，简称逻辑流。进程轮流使用处理器， 每个进程执行它的流的一部分，然后被<font color=red>抢占(preempted)</font>(暂时挂起)，然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。

### 3.2 并发流

​	一个逻辑流的执行在时间上与另一个流重叠，称为<font color=red>并发流(concurrent flow)</font>，这两个流被称为<font color=red>并发地运行</font>，准确的说是两个流互相并发，多个流并发地执行的一般现象被称为<font color=red>并发(concurrency)</font>。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<font color=red>并行流(parallel flow)</font>，它们<font color=red>并行地运行(running in parallel)</font>，且<font color=red>并行地执行(parallel execution)</font>。（运行 和 执行 不一样，并发流称之为运行，并行流称之为执行）

### 3.3 私有地址空间

​	进程为每个程序提供它自己的私有地址空间。

### 3.4 用户模式和内核模式

​	处理器通常是用某个控制寄存器中的一个<font color=red>模式位(mode bit)</font>来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在<font color=red>内核模式</font>中；没有设置模式位时，进程就运行在<font color=red>用户模式</font>中。

- 内核模式：可以执行指令集中的任何指令，可以访问系统中的任何内存位置。

- 用户模式：不允许执行特权指令，不允许直接引用地址空间中内核内的代码和数据（通过系统调用可以）

进程从用户模式变为内核模式的唯一方法使通过中断、故障或者陷入系统调用这样的异常。

### 3.5 上下文切换

​	操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文。内核调度新进程，并使用一种称为上下文切换的机制来将控制权转移到新的进程。上下文切换：

1. 保存当前进程的上下文；

2. 恢复某个先前被抢占的进程被保存的上下文；

3. 将控制传递给这个新恢复的进程。

当内核代表用户执行系统调用时，可能会发生上下文切换；中断也可能引发上下文切换。

## 4. 进程控制

