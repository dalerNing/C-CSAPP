<center>08. 异常控制流(Exceptional Control Flow, ECF)</center>
-----
[TOC]

## 1. 学习目标



## 2. 异常控制流

​	从处理器上电到断电为止，程序计数器假设一个值的序列`a0,a1,...,ak,...`，其中，每个`ak`是某个指令`Ik`的地址。每次从`ak`到`ak+1`的过渡称为<font color=red>控制转移</font>。这样的控制转移序列叫做处理器的<font color=red>控制转移</font>。到目前为止，我们已经学过了两种改变控制流的方式：

- 跳转、分支

- 调用、返回

这两种操作对应于程序内部状态变化的反映，没有办法应对更加复杂的系统状态变化，例如：系统状态不是被内部程序变量捕获的、也不一定要和程序的执行相关，如下：

- 一个硬件定时器产生信号

- 包到达网络适配器

- 子进程结束，创造这些子进程的父进程得到通知

​	现代操作系统通过使控制流发生突变来对上述情况作出反应，这些突变，称为<font color=red>异常控制流(Exceptional Control Flow, ECF)</font>。异常控制流发生在计算机系统的各个层次。

- **异常(exception)**：异常位、于硬件和操作系统交界的部分，响应硬件检测到的事件。

- **系统调用**：系统调用是为应用程序提供到操作系统的入口点的异常，<font color=red>属于异常，不属于进程切换</font>。

- **进程切换**：在硬件计时器和操作系统下，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。

- **信号**：信号位于应用层和操作系统的交界之处。

- **非本地跳转**：ECF 的一种应用层实现形式。

  接下来我们就来分析这四种跨越计算机不同层级的异常控制流机制。

## 3. 异常(Exception)

​	异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。<font color=red>异常</font>就是控制流中的突变，用来响应处理器状态中的某些变化。处理器状态变化称为<font color=red>事件</font>。当事件发生时，处理器会通过一张叫做<font color=red>异常表(exception table)</font>的跳转表，进行一个<font color=red>间接过程调用(异常)</font>，到一个专门设计用来处理这类事件的操作系统子程序，即<font color=red>异常处理程序(exception handler)</font>。具体过程如下图所示：

![](./images/8-3.jpg)

### 3.1 异常处理

​	系统中为异常分配了一个唯一的非负整数的<font color=red>异常号(exception ber)</font>。异常号主要有两种：

- 处理器设计者分配：例如被零除、缺页、内存访问违例、断点以及算术运算溢出。

- 操作系统内核设计者分配：例如系统调用和来自外部I/O设备的信号。

  <font color=red>异常(间接过程调用)</font>类似于过程调用，但是有一些重要的不同之处：

- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中；异常则是根据其类型，返回地址要么是当前指令，要么是下一条指令或不返回。

- 处理器也把一些额外的处理器状态压入栈里，在处理程序返回时，重新开始执行中断的程序会需要这些状态。

- 如果控制从应用程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中.

- 异常处理程序运行在<font color=red>内核模式</font>下，对所有的系统资源都有完全的访问权限。

### 3.2 异常的分类

​	异常可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)、终止(error)。

| 类别 |       原因        | 异步/同步 |       返回行为       |        示例         |
| :--: | :---------------: | :-------: | :------------------: | :-----------------: |
| 中断 | 来自I/O设备的信号 |   异步    | 总是返回到下一条指令 | 计时器中断、I/O中断 |
| 陷阱 |    有意的异常     |   同步    | 总是返回到下一条指令 |   系统调用、断点    |
| 故障 | 潜在可恢复的错误  |   同步    |  可能返回到当前指令  |      缺页异常       |
| 终止 |  不可恢复的错误   |   同步    |       不会返回       |      非法指令       |

​	<font color=red>异步异常</font>称之为中断、硬件中断不是由任何一条专门的指令造成的，从这个意义上说它是异步的；<font color=red>同步异常</font>是执行当前指令的结果，我们把这类指令叫做<font color=red>故障指令(faulting instruction)</font>。

#### 1. 中断

​	中断的异常处理程序称为<font color=red>中断处理程序(interrupt handler)</font>。

![](./images/8-3-1.png)

<center><font color=red>中断处理(interrupt handling)</font></center>

#### 2. 陷阱和系统调用

​	陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的借口，叫做<font color=red>系统调用</font>。用户程序经常需要向内核请求服务，比如读一个文件(read)、加载一个新的程序(execve)、创建一个新的进程(fork)、或者终止当前进程(exit)，系统提供了一条特殊的`syscall n`指令，执行`syscall`指令会导致一个到异常处理程序的陷阱，这个处理器程序解析参数，并调用适当的内核程序。

![](./images/8-3-2.png)

<center><font color=red>陷阱处理(trap handling)</font></center>

#### 3. 故障

​	故障由错误情况引起，它能被故障处理程序修正。当故障发生时，转移至故障处理程序。如果能修正这个错误情况，返回故障的指令并重新执行它；否则，返回到内核中的`abort`例程，终止引起故障的应用程序。

![](./images/8-3-3.png)

<center><font color=red>故障处理(fault handling)</font></center>

​	一个典型的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。然后将相应的页加载成功后，返回故障的指令，正确执行。

#### 4. 终止

​	终止是不可恢复的致命错误造成的成果，处理程序将控制权返回给一个`abort`例程，该例程会终止这个应用程序。

### 3.3 Linux/x86-64 系统中的异常

​	x86-64 系统定义了高达256种不同的异常类型，0～31 号码对应的是由Intel架构师定义的异常，32～255 号码对应的是操作系统定义的中断和陷阱。

#### 1. Linux/x86-64故障和终止

- 除法错误
- 一般保护检查
- 缺页
- 机器检查

#### 2. Linux/x86-64 系统调用

​	系统调用和与它们相关联的包装函数都称为<font color=red>系统级函数</font>。所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的。

## 4. 进程