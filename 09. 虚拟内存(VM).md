---

---

<center>09. 虚拟内存(Virtual Memory, VM)</center>
-----
[TOC]

# 1. 虚拟内存

​	<font color=red>虚拟内存(Virtual Memory, VM)</font>是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。虚拟内存提供了三个重要的能力：

- 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种模式，它高效地使用了主存。

- 它为每个进程提供了一致的地址空间，从而简化了内存管理。

- 它保护了每个进程的地址空间不被其他进程破坏。

虚拟内存是计算机系统最重要的概念之一，它成功的一个主要原因就是因为它是沉默地、自动地工作（虚拟内存类似于指令集，即指令集是 CPU 本身；虚拟内存是 CPU 和 MMU 组合工作的集合，将虚拟内存转成物理内存的过程就是虚拟内存的重要性）。

- 虚拟内存是核心的：虚拟内存遍及计算机系统的所有层面。

- 虚拟内存是强大的：虚拟内存给予应用程序强大的能力，可以创建和销毁内存片(chunk)、将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。

- 虚拟内存是危险的：每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如 `malloc` 这样的动态分配程序时，它就会和虚拟内存发生交互。

# 2. 从物理内存到虚拟内存

CPU 访问内存有两种方式：

- 物理寻址：CPU 访问内存直接使用<font color=red>物理地址(Physical Address, PA)</font>进行寻址。

- 虚拟寻址：CPU 通过生成一个<font color=red>虚拟地址(Virtual Address, VA)</font>来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。如下图所示：

![](images/9-1.jpg)

​	将一个虚拟地址转换为物理地址的任务叫做<font color=red>地址翻译(address translation)</font>。CPU 芯片上叫做<font color=red>内存管理单元(Memory Management Unit, MMU)</font>的专用硬件，利用存放在主存中的查找表来动态的翻译虚拟地址，该表的内容由操作系统管理。

地址空间：<font color=red>地址空间(address apace)</font>是一个非负整数地址的有序集合。此外，一个系统还有一个*虚拟地址空间*和*物理地址空间*。

# 3. 虚拟内存的三个角色

## 3.1 虚拟内存作为缓存的工具

### 1. 页面

​	概念上而言，虚拟内存被组织为一个由==存放在磁盘==上的 *N* 个连续字节的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引；磁盘上数组的内容缓存在主存中。虚拟内存系统通过将虚拟内存分割为称为<font color=red>虚拟页(Virtual Page, VP)</font>的大小固定的块来处理这个问题。每个虚拟页的大小为 *P = 2^p^* 字节。 类似的，物理内存被分割为<font color=red>物理页(Physical Page, PP)</font>，大小也为 *P* 字节。在任意时刻，虚拟页面都只有以下三种状态：

- 未分配的：虚拟内存系统还未分配页。
- 缓存的：当前缓存在物理内存中的已分配页。
- 未缓存的：未缓存在物理内存中的已分配页

![](images/9-2.jpg)

​	*DRAM 缓存*作为虚拟内存系统的缓存，它在主存中缓存虚拟页。由于 *DRAM 缓存*的组织结果完全是由巨大的不命中开销驱动的，所以我们的目标就是尽可能从 DRAM 中取数据。为此，我们需要：

- 更大的页尺寸：通常是 4KB～2MB
- 全相连：任何虚拟页都可以放置在任何物理页中
- 更复杂精密的替换算法
- DRAM 缓存总是使用写回，而不是直写

### 2. 页表

​	<font color=red>页表(page table)</font>是==存储在物理内存==中的数组，一个由<font color=red>页表条目(Page Table Entry, PTE)</font>组成的数组，其索引称为<font color=red>页表条目地址(PTEA)</font>。我们假设每个 PTE 是由一个*有效位*和 *n* 位地址字段组成：

- 设置有效位表示物理页缓存了该虚拟页，地址字段表示相应的物理页地址；（对应于虚拟页面 缓存的）

- 未设置有效位，若有地址字段，表示该虚拟页在磁盘上的起始位置；（对应于虚拟页面 未缓存的）

- 未设置有效位，若空地址，表示该虚拟页未分配；（对应于虚拟页面 未分配的）

![](images/9-3.jpg)

因为有页表可查，就会遇到三种情况：页命中(page hit)、缺页(page fault)、分配页面。

命中的时候，即访问页表中蓝色条目的地址，因为在 DRAM 中有对应的数据，可以直接访问。

不命中的时候，即访问页表中灰色条目的时候，因为 DRAM 中没有对应的数据，会触发一个==缺页异常==，调用内核中的缺页异常处理程序，完成之后重新执行访问指令，这是就会变成页命中。

分配页面时，就是在磁盘上创建空间并更新 PTE，使它指向磁盘上这个新创建的页面，但不会复制到 DRAM，只有当出现缺页时才拷贝数据。

## 3.2 虚拟内存作为内存管理的工具

![](images/9-4.jpg)

​	操作系统为每个进程提供了==一个独立的页表==，按需页面调度和独立的虚拟地址空间的结合，对系统中内存的利用和管理造成了深远的影响。特别地，*VM* 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。

- 简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。可执行文件是独立于物理内存中代码和数据的最终位置的。

- 简化加载：Linux 加载器为代码和数据段分配虚拟页，把他们分配为==未缓存的==，将页表条目指向目标文件中适当的位置（页表条目指向的是磁盘地址）。加载器从不从磁盘到内存实际复制任何数据，只有当引用发生缺页异常时才会自动的调入数据页。

- 简化共享：共享页面。

- 简化内存分配：即 `malloc` 内存分配，需要 *k* 个连续的虚拟内存页面时；物理内存页面不需要提供 *k* 个连续的物理内存页面

<font color=red>内存映射(memory mapping)</font>：将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作*内存映射*。

## 3.3 虚拟内存作为内存保护的工具

​	现代操作系统需要提供手段来控制对内存系统的访问，由于每次 CPU 生成一个地址时，MMU 都会读一个PTE，所以我们可以在 PTE 上添加一些额外的许可位来控制读一个虚拟页面内存的访问，如下图所示：

![](images/9-5.jpg)

# 4. 地址翻译

开始之前先来了解一下参数：
$$
N=2^n, M=2^m, P=2^p
$$
其中 `N` 表示虚拟地址空间中的地址数量，`M` 表示物理地址空间中的地址数量，`P`  表示页的大小(字节)。

虚拟地址(Virtual Address, VA)的组成部分：
$$
VA=VPN+VPO=TLBT+TLBI+VPO
$$

- `VPN`：虚拟页号
- `VPO`：虚拟页面偏移量
- `TLBT`：TLB 标记
- `TLBI`：TLB 索引

物理地址(Physical Address, PA)的组成部分：
$$
PA=PPN+PPO=CT+CI+CO
$$

- `PPN`：物理页号
- `PPO`：物理页面偏移量
- `CT`：高速缓存标记
- `CI`：高速缓存索引
- `CO`：缓存块内的字节偏移量

