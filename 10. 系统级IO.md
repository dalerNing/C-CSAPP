<center>10. 系统级I/O</center>

-----
[TOC]

# 1. Unix I/O

​	一个 Linux 文件就是一个 *m* 个字节的序列：
$$
B_o, B_1, ..., B_k, ..., B_{m-1}
$$
所有的 I/0 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 <font color=red>Unix I/O</font>，这使得所有的输入和输出都能以一种统一且一致的方式来执行。

- **打开文件**：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做<font color=red>描述符</font>，它在后续对此文件中的所有操作中标识这个文件。Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(0)、标准输出(1)、标准错误(2)。

- **改变当前的文件位置**：对于每个打开的文件，内核保持着一个文件位置 *k*，这个文件位置是从文件开头起始的字节偏移量。

- **读写文件**

- **关闭文件**：内核释放文件打开时创建的数据结构，并将这个文件描述符恢复到可用的描述符池中。

# 2. 文件

每个 Linux 文件都有一个类型来表明它在系统中的角色：

- 普通文件(regular file)：包含任意数据。一般分为<font color=red>文本文件(text file)</font>和<font color=red>二进制文件(binary file)</font>。
- <font color=red>目录(directory)</font>：是包含一组<font color=red>链接(link)</font>的文件，其中每个链接都将一个<font color=red>文件名(filename)</font>映射到一个文件，这个文件可以是另一个目录。每个目录至少包含两个条目：`.` 是到该目录本身的链接；`..` 是到父目录的链接。
- <font color=red>套接字(socket)</font>：是用来与另一个进程进行跨网络通信的文件。

其他文件类型包含<font color=red>命名通道(named pipe)</font>、<font color=red>符号链接(symbolic link)</font>、以及<font color=red>字符和块设备(character and block device)</font>，这些不在本书的讨论范畴。

# 3. 文件操作

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

/* 打开文件：返回的文件描述符总是在进程中当前没有打开的最小描述符 */
int open(char *filename, int flags, mode_t mode);

/* 关闭文件：成功返回 0；出错返回 -1 */
int close(int fd);

/* 读文件 */
ssize_t read(int fd, void *buf, size_t n);

/* 写文件 */
ssize_t write(int fd, const void *buf, size_t n);

/* 随机访问 */
off_t lseek(int fd, off_t offset, int whence);
```

`read` 函数从描述符为 fd 的当前文件位置复制最多 *n* 个字节到内存位置 buf。返回值 -1 表示一个错误；返回值 0 表示 EOF；否则，返回值表示的是==实际传送的字节数量==。

`write` 函数从内存位置 buf 复制至多 *n* 个字节到描述符 fd 的当前文件位置。返回值 -1 表示一个错误；否则，返回值表示的是传送的字节数量。

特殊情况下，`read` 和 `write` 传送的字节比应用程序要求的要少。这些不足值(short count)不表示有错误，出现这样的情况原因有：

- 读时遇到 EOF
- 从终端读文本行
- 读和写网络套接字(socket)

# 4. 用 RIO 包健壮的读写