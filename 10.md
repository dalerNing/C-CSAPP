# 1. 进程、线程

## 1. 1 进程与线程的基本概念

- **进程**：是系统进行资源分配和调度运行的基本单位。进程的经典定义就是一个执行中程序的实例。
- **线程**：是系统进行调度分配的基本单位。每个进程至少包含一个线程，那就是主线程。线程自己只拥有很少的系统资源，如栈、栈指针、程序计数器、通用目的寄存器和条件码；所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。

## 1.2 进程与线程的区别

线程也称为轻量级进程。下面，我们主要从调度、并发性、系统开销、资源拥有等方面来对线程和进程进行比较。

- **调度**：引入线程的操作系统中，线程作为 CPU 调度和分配的基本单位，进程则作为资源拥有的基本单位，线程可以轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换（上下文切换），从而避免了昂贵的系统调用。
- **并发性**：引入线程的操作系统中，不仅进程间可以并发执行，而且一个进程中的多个线程间也可以并发执行，使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统的吞吐量。
- **系统开销**：线程只拥有很少的系统资源，却可以访问其隶属进程的资源，如代码段、数据段、及已打开的文件、I/O 设备等系统资源。
- **资源拥有**：创建或撤销进程时，系统都要分配或回收资源。因此，操作系统付出的开销将显著地大于创建或撤销线程的开销。线程切换主要保存栈、栈指针、程序计数器、通用目的寄存器和条件码；进程切换通过上下文切换实现，要保存和恢复整个虚拟内存空间，把控制交给新进程。

进程的状态：运行、停止、终止。

线程的状态：就绪、运行、等待、消亡。

# 2. 线程同步

## 2.1 互斥量

**互斥量（mutex）**：从本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后解锁互斥量。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成可运行状态的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。这样的机制解决了共享资源的**互斥访问**问题。

死锁：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

## 2.2 读写锁

**读写锁（read-write lock）**：

## 2.3 条件变量

## 2.4 信号量

## 

# 3. 其他并发问题

- 线程安全
- 可重入性
- 使用已存在的库函数
- 竞争
- 死锁

